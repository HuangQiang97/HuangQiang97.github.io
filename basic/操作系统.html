<!doctype html>
<html style='font-size:18px !important'>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 600;
    src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('file:///C://Users//huangqiang//AppData//Roaming//Typora/themes/vue/6xKydSBYKcSV-LCoeQqfX1RYOo3i54rwlxdu.woff2') format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}@import '';

:root {
    --side-bar-bg-color: #fff;
    --control-text-color: #777;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --font-jbmono: 'JetBrains Mono' !important;
}

html {
    font-size: 16px;
}

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

#write {
    max-width: 1024px;
    margin: 0 auto;
    /*padding: 20px 30px 100px;*/
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: #42b983;
    font-weight: 600;
    padding: 0 2px;
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}

h2 tt,
h2 code {
    font-size: inherit !important;
}

h3 tt,
h3 code {
    font-size: inherit !important;
}

h4 tt,
h4 code {
    font-size: inherit !important;
}

h5 tt,
h5 code {
    font-size: inherit !important;
}

h6 tt,
h6 code {
    font-size: inherit !important;
}

h2 a,
h3 a {
    color: #34495e;
}

h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}

h2 {
    font-size: 1.75rem;
    line-height: 1.225;
    margin: 35px 0 15px;
    padding-bottom: 0.5em;
    border-bottom: 1px solid #ddd;
}

h3 {
    font-size: 1.4rem;
    line-height: 1.43;
    margin: 20px 0 7px;
}

h4 {
    font-size: 1.2rem;
}

h5 {
    font-size: 1rem;
}

h6 {
    font-size: 1rem;
    color: #777;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

blockquote {
    border-left: 4px solid #42b983;
    padding: 10px 15px;
    color: #777;
    background-color: rgba(66, 185, 131, .1);
}

table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

table tr:nth-child(2n),
thead {
    background-color: #fafafa;
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

#write strong {
    padding: 0 1px;
}

#write em {
    padding: 0 5px 0 2px;
}

#write table thead th {
    background-color: #f2f2f2;
}

#write .CodeMirror-gutters {
    border-right: none;
}

#write .md-fences {
    border: 1px solid #F4F4F4;
    -webkit-font-smoothing: initial;
    margin: 0.8rem 0 !important;
    padding: 0.3rem 0 !important;
    line-height: 1.43rem;
    background-color: #F8F8F8 !important;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.85rem;
    word-wrap: normal;
}

#write .CodeMirror-wrap .CodeMirror-code pre {
    padding-left: 12px;
}

#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: #e96900;
    background-color: #f8f8f8;
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: #e96900;
}

/* heighlight. */
#write mark {
    background-color: #EBFFEB;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
    color: #222;
    font-weight: 500;
}

#write del {
    padding: 1px 2px;
}

.cm-s-inner .cm-link,
.cm-s-inner.cm-link {
    color: #22a2c9;
}

.cm-s-inner .cm-string {
    color: #22a2c9;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

.md-fences {
    background-color: #f8f8f8;
}

.md-diagram-panel {
    position: static !important;
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

#write > h3.md-focus:before {
    left: -1.5625rem;
    top: .375rem;
}

#write > h4.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h5.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h6.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: inherit;
}

.md-toc {
    margin-top: 20px;
    padding-bottom: 20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

/** focus mode */

.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}



</style><title>操作系统</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=' first-line-indent'><h3 id='操作系统'><span>操作系统</span></h3><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n0"><a class="md-toc-inner" href="#操作系统">操作系统</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n3"><a class="md-toc-inner" href="#进程线程协程">进程、线程、协程</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n12"><a class="md-toc-inner" href="#linux进程状态">Linux进程状态</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n28"><a class="md-toc-inner" href="#进程通信">进程通信</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n44"><a class="md-toc-inner" href="#线程通信">线程通信</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n49"><a class="md-toc-inner" href="#内存分段分页">内存分段、分页</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n58"><a class="md-toc-inner" href="#内存调度">内存调度</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n72"><a class="md-toc-inner" href="#磁盘调度">磁盘调度</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n88"><a class="md-toc-inner" href="#进程调度">进程调度</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n104"><a class="md-toc-inner" href="#进程切换">进程切换</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n112"><a class="md-toc-inner" href="#用户态内核态">用户态、内核态</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n114"><a class="md-toc-inner" href="#调度">调度</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n116"><a class="md-toc-inner" href="#linux调度">Linux调度</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n123"><a class="md-toc-inner" href="#死锁">死锁</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n129"><a class="md-toc-inner" href="#尾递归">尾递归</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n131"><a class="md-toc-inner" href="#cas">CAS</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n133"><a class="md-toc-inner" href="#阻塞非阻塞与同步异步">阻塞非阻塞与同步异步</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n145"><a class="md-toc-inner" href="#io多路复用">I/O多路复用</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n164"><a class="md-toc-inner" href="#nio">NIO</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n175"><a class="md-toc-inner" href="#上下文切换">上下文切换</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n186"><a class="md-toc-inner" href="#进程内存布局">进程内存布局</a></span></p></div><h5 id='进程线程协程'><span>进程、线程、协程</span></h5><p><span>一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。</span></p><ul><li><span>进程：执行的程序、资源分配、由程序+数据集合+进程控制块组成，独立的堆栈、由操作系统调度（抢占式调度）、切换开销大(栈、寄存器、虚拟内存、文件句柄等)、稳定安全、进程间通信。</span></li><li><span>线程：多任务、调度和分派、独立的栈和共享的堆，由操作系统调度（抢占式调度）、共享进程资源、使用共享内存进行通信、上下文切换很快，资源开销较少、不够稳定容易丢失数据、多核并行高性能、适合IO密集型、通信不需要OS干预、用户线程（轻量级进程）由内核线程支持（一对一模型（真正的并发、独立、数量有限、调度开销大）、多对一模型（由用户态切换、阻塞）、多对多模型）。</span></li><li><span>协程：基于线程之上，比线程更加轻量级、存在用户态的轻量级线程、用户控制调度（对内核透明，内存占用小、单线程进程、无陷入和上下文切换、难以实现强制的 CPU 控制权切换，主动出让控制权）、适用于被阻塞大量并发的场景、不适用于大量计算的多线程。</span></li></ul><h5 id='linux进程状态'><span>Linux进程状态</span></h5><ul><li><span>可执行状态：正在 CPU 上执行的进程定义为 RUNNING 状态、而将可执行但是尚未被调度执行的进程定义为 READY 状态（获得了除了处理器之外的一切所需资源），linux 下统一为 TASK_RUNNING 状态。</span></li><li><span>可中断的睡眠状态：等待事件的发生（比如等待信号量、对应事件的等待队列中、事件发生进程被唤醒），而被挂起。</span></li><li><span>不可中断的睡眠状态：进程处于睡眠状态，进程是不可中断的（不响应异步信号，内核的某些处理流程是不能被打断的，比如IO操作与对应的物理设备进行交互）。</span></li><li><span>暂停状态或跟踪状态：收到SIGSTOP信号。</span></li><li><span>退出状态（EXIT_ZOMBIE）：僵尸进程、所有资源将被回收，除了 task_struct 结构（保存了进程的退出码，父进程逻辑判断）、内核通知父进程回收（父进程结束则被收养）。</span></li><li><span>退出状态（ EXIT_DEAD）：即将被销毁、彻底释放。</span></li><li><span>进程的初始状态：将调用进程（fork、clone、vfork）复制一份，得到子进程、独立。</span></li></ul><h5 id='进程通信'><span>进程通信</span></h5><ul><li><span>匿名管道：单工、FIFO、柱塞式、亲缘进程、本质为内核缓冲区（内存中）、约定格式。有名管道（磁盘文件、非亲缘）</span></li><li><span>信号：sigterm、sigkill、中断机制的一种模拟，异步通信方式（阻塞）、硬件来源、软件终止、三种处理方式</span></li><li><span>消息队列：内核中的消息链表、特定的格式、FIFO、随机查询。</span></li><li><span>共享内存：直接读写同一块内存空间、将其映射到进程的私有地址空间（内存逻辑地址）无拷贝、需要同步机制。</span></li><li><span>信号量：资源计数器、进程间同步、创建等待释放、等待队列、原子操作（P、V原语）、进程的线程间共享。</span></li><li><span>互斥量：临界区视为资源、原语加锁解锁、等待队列、管程（封装、wait、signal、synchronized方法）</span></li><li><span>套接字：IP+Port、远程、TCP/UDP。</span></li></ul><h5 id='线程通信'><span>线程通信</span></h5><p><span>1，锁机制（互斥锁提供了以排他方式防止数据结构被并发修改的方法，条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 wait/notify 等待、Volatile 内存共享，CountDownLatch 并发工具）;信号量机制(Semaphore);信号机制(Signal)。</span></p><p><span>2，消息队列（rabbitMQ）:当不需要立即获得结果,异步处理：写入消息队列后立即返回客户端,无需等待；限流削峰：请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲, 极大地减少了业务处理系统的压力；</span></p><p><span>点对点模式：点对点的Queue，即Producer发送消息到指定的Queue，接收方从Queue收取消息。</span></p><p><span>一对多的Topic，即Producer发送消息到指定的Topic，任意多个在线的接收方均可从Topic获得一份完整的消息副本。当Producer想要发送消息的时候，它将消息发送给指定的Exchange，由Exchange将消息根据各种规则投递到一个或多个Queue（）路由。送消息时，使用</span><code>rabbitTemplate.convertAndSend(exchange, routingKey, message)</code><span>可以指定Exchange、Routing Key以及消息本身。接收消息时，需要在消息处理的类上标注</span><code>@RabbitListener</code><span>指明要监听的queue，通过多个</span><code>@RabbitHandler</code><span>标注的方法接收不同类型的消息。</span></p><h5 id='内存分段分页'><span>内存分段、分页</span></h5><p><span>逻辑地址（完整、连续、进程隔离、更大内存）；物理地址（非连续）；地址转换</span></p><ul><li><span>段：内存块单元、逻辑完整（保护、共享）、代码、堆栈、段号+偏移量、大小可变、段表（段号-&gt; 物理地址）、适合处理复杂系统的逻辑分区</span></li><li><span>分页：大小固定、物理连续、页表（进程不共享，页号-&gt; 物理块号）、页号（块号）+偏移量、缓存（局部性原理）、多级页表（逻辑地址大页表太长、页表的页表、多级索引）、适合管理物理内存、利用率高。</span></li><li><span>段页：先分段再段内分页、段号+页号+偏移、段表（段号-&gt;页表地址）、页表（页号-&gt;块号）</span></li></ul><h5 id='内存调度'><span>内存调度</span></h5><ul><li><span>当 CPU 访问的页面不在物理内存时（逻辑地址），便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，最后把正在访问的页面装入到这个物理页中。</span></li><li><span>最佳页面置换算法（</span><em><span>OPT</span></em><span>）：置换在「未来」最长时间不访问的页面。因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间，最佳页面置换算法作用是为了衡量你的算法的效率。</span></li><li><span>先进先出置换算法（</span><em><span>FIFO</span></em><span>）：选择在内存驻留时间很长的页面进行中置换。</span></li><li><span>最近最久未使用的置换算法（</span><em><span>LRU</span></em><span>）：选择最长时间没有被访问的页面进行置换， LRU 则是通过「历史」的使用情况来推测要淘汰的页面，近似最优置换算法。代价很高：为了完全实现 LRU，需要在内存中维护一个所有页面的链表。</span></li><li><span>时钟页面置换算法（</span><em><span>Lock</span></em><span>）：把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面：如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果访问位是 1 就清除访问位改为0，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</span></li><li><span>最不常用置换算法（</span><em><span>LFU</span></em><span>）：当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。成本高：要增加一个计数器来实现。记忆力太好：比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</span></li></ul><h5 id='磁盘调度'><span>磁盘调度</span></h5><ul><li><span>多层盘片，盘片中的每一层分为多个磁道，每个磁道分多个扇区。磁盘选择（电子）+磁道选择（机械）+扇区选择(转速)。通过优化磁盘的访问请求顺序来做到的提高磁盘的访问性能。</span></li><li><span>先来先服务算法：如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</span></li><li><span>最短寻道时间优先算法：优先选择从当前磁头位置所需寻道时间最短的请求，后续请求距离较小，导致某些请求的饥饿。</span></li><li><span>扫描算法算法：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向。不会产生饥饿现象，但是中间部分相比其他部分响应的频率会比较多，每个磁道的响应频率存在差异。</span></li><li><span>循环扫描算法：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应一个方向上的请求。响应频率相对比较平均</span></li><li><span>LOOK ：磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中会响应请求。</span></li><li><span>C-LOOK：磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中不会响应请求。</span></li></ul><h5 id='进程调度'><span>进程调度</span></h5><ul><li><span>先来先服务调度算法：当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</span></li><li><span>最短作业优先调度算法：优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。长作业饥饿。</span></li><li><span>高响应比优先调度算法：每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。优先级=(已等待事件+要求服务时间)/要求服务时间。这样短作业的进程容易被选中运行；对于长作业当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会。</span></li><li><span>时间片轮转调度算法：每个进程被分配一个时间段，如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</span></li><li><span>最高优先级调度算法：从就绪队列中选择最高优先级的进程进行运行，</span></li><li><span>多级反馈队列调度算法：多个队列，每个队列优先级从高到低，同时优先级越高时间片越短，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成。如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了。</span></li><li><span>O(1)、CFS。</span></li></ul><h5 id='进程切换'><span>进程切换</span></h5><ul><li><span>进程切换：必然陷入内核态需要切换内核态堆栈，PCB（用于描述控制进程的运行）的切换，切换页表（进程间虚拟内存独立），刷新TLB。</span></li><li><span>线程切换：线程共享资源，所以不需要切页表。一个线程执行至少需要寄存器和堆栈，线程切换本质就是堆栈的切换。</span></li><li><span>每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间，进程切换涉及虚拟地址空间的切换而线程不会。使用Cache（TLB）来缓存常用的地址映射，这样可以加速页表查找，由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低,表现出来的就是程序运行会变慢。</span></li></ul><h5 id='用户态内核态'><span>用户态、内核态</span></h5><p><span>系统调用将 Linux 整个体系分为用户态和内核态；内核态：控制计算机的硬件资源、稳定安全；用户态：提供应用程序运行的空间、系统调用（os接口）、库函数对系统调用进行封装；给不同的操作给与不同的 “权限”、切换方式（系统调用、异常、外设中断）</span></p><h5 id='调度'><span>调度</span></h5><p><span>（饥饿、长短作业公平性、优先级）先来先服务、短作业优先、时间片轮转、多级队列（新进程优先级高、优先级高时间片越短、抢占式、级别降低）。</span></p><h5 id='linux调度'><span>Linux调度</span></h5><p><span>内核线程、调度基于线程，nice值越低优先级越高</span></p><ul><li><span>O(1)：常数时间、数组+链表、活动队列+过期队列、多级队列140优先级、高优先级长时间片、优先级调度、时间片用完加入过期队列（防止饿死）、活动队列空交换多动、过期队列、核心间队列独立、队列维护bitmap指示那些优先级还有任务（寻找最高优先级任务=寻找bitmap中最高位为1 的bit，cpu指令优化O(1),然后数组支持随机访问=&gt;O(1)）、交互任务性能差</span></li><li><span>CFS：红黑树（增删查log(N)）、不直接根据优先级分配时间、依据vruntime（nice因子大时间流逝快）决定优先级、vruntime插入红黑树、左下角vruntime最小（优先被调度）、定期将运行任务阿vruntime与左下角比较（抢占）、选择O(1)、插入O(log(N))</span></li></ul><h5 id='死锁'><span>死锁</span></h5><p><span>前提：互斥资源、请求新资源、不可抢占、等待关系闭环。</span></p><p><span>死锁检测：单资源单向有向图环检测（以每个节点为起点，深度优先、重复）。</span></p><p><span>死锁恢复：抢占恢复（用完归还）、杀死进程（选择副作用小的进程）。</span></p><p><span>死锁避免：安全前提（存在非死锁序列）下分配资源（银行家算法）。</span></p><p><span>死锁预防：非独占（假脱机打印）、非占有等待（一次请求全部资源）、破坏不可抢占（请求失败释放占有资源）。破坏等待（资源编号、请求资源序号升序、无环产生）</span></p><h5 id='尾递归'><span>尾递归</span></h5><p><span>传统递归在递归返回后好需要继续运算，保留栈帧；空间O(N);尾递归在递归返回后无后续运算，当前递归结果已被收集（二叉查找树的左右子节点为参数），无需保留栈帧，空间O(1)</span></p><h5 id='cas'><span>CAS</span></h5><p><span>乐观锁；根据地址v取值A=get(v)-&gt;B=f(A)-&gt;A==get(v)-&gt;成立则将B写入v,失败则不断重复至成功；重复读取get(v)，单变量原子性（封装），ABA问题（版本号比较）</span></p><h5 id='阻塞非阻塞与同步异步'><span>阻塞非阻塞与同步异步</span></h5><p><a href='https://www.cnblogs.com/loveer/p/11479249.html' target='_blank' class='url'>https://www.cnblogs.com/loveer/p/11479249.html</a></p><p><span>IO分两阶段1.数据准备阶段，2.内核空间复制数据到用户进程缓冲区（用户空间）阶段</span></p><ul><li><span>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态，对同一个线程来说的，阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞。阻塞调用是指调用结果返回之前，主动挂起自己的操作，进程转变为“等待”的状态，调用线程只有在得到结果之后（同步：监测，异步：通知）才会返回。非阻塞调用指被调用后立即返回一个状态值，无需等I/O操作彻底完成，根据返回的状态，线程可以自行其它任务，（同步：轮询，异步：通知）。</span></li><li><span>同步和异步对应于调用者与被调用者，它们是线程之间的关系，关注的是消息通知的机制。同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果不阻塞，发起I/O请求后仍需要继续执行，返回时不一定知道结果，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数，操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。同步IO即调用者需要等待被调用者返回结果，由处理消息者自己去等待消息是否被触发，之后才会进行下一步操作（需要等待或者轮询内核I/O操作完成后才能继续执行）。</span></li><li><span>阻塞与非阻塞与是否同步异步无关。</span></li><li><span>一个非阻塞I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据，可以是完整的结果，也可以是不完整的结果，还可以是一个空值。而异步I/O系统调用 read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</span></li></ul><h5 id='io多路复用'><span>I/O多路复用</span></h5><p><span>通过一种机制，可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，没有就绪事件时，就会阻塞交出cpu。多路是指多个链接，复用指的是复用同一线程。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</span></p><p><a href='https://developer.aliyun.com/article/763247' target='_blank' class='url'>https://developer.aliyun.com/article/763247</a></p><p><a href='https://juejin.cn/post/6931543528971436046' target='_blank' class='url'>https://juejin.cn/post/6931543528971436046</a></p><ul><li><p><span>select：时间复杂度O(n)，通过设置或者检查存放fd标志位的数据结构（fd数组为整型数组，用于保存文件描述符）来进行下一步处理，它仅仅知道有I/O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流，找出能读出数据，或者写入数据的流，效率较低。单个进程可监视的fd数量被限制，即能监听端口的大小有限。内核需要将消息传递到用户空间时需要内核拷贝动作，每次调用select，都需要把fd集合从用户态拷贝到内核态。</span></p><p><span>1，用户线程调用select，将fd_set从用户空间拷贝到内核空间 2. 内核在内核空间对fd_set遍历一遍，检查是否有就绪的socket描述符，如果没有的话，就会进入休眠，直到有就绪的socket描述符 3. 内核返回select的结果给用户线程，即就绪的文件描述符数量 4. 用户拿到就绪文件描述符数量后，再次对fd_set进行遍历，找出就绪的文件描述符 5. 用户线程对就绪的文件描述符进行读写操作。</span></p></li><li><p><span>poll：时间复杂度O(n)，本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。但是它没有最大连接数的限制，原因是它是基于链表来存储fd的。每次调用poll，都需要把fd集合从用户态拷贝到内核态。</span></p><p><span>1,用户线程调用poll系统调用，并将文件描述符链表拷贝到内核空间。2，内核对文件描述符遍历一遍，如果没有就绪的描述符，则内核开始休眠，直到有就绪的文件描述符。3，返回给用户线程就绪的文件描述符数量。4，用户线程再遍历一次文件描述符链表，找出就绪的文件描述符。5，用户线程对就绪的文件描述符进行读写操作。</span></p></li><li><p><span>epoll：时间复杂度O(1)，epoll可以理解为event poll，给每个fd注册一个回调函数，当fd对应的设备发生IO事件时，就会调用这个回调函数，将该fd放到一个链表中，然后唤醒在epoll_wait中进入睡眠的进程，最后只要判断一下就绪链表是否为空就行了，非空就从该链表中取出一个fd，以此达到O（1）的时间复杂度。效率提升，不是轮询的方式；根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，而跟连接总数无关，会随着fd数量上升而效率下降。使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间。</span></p><p><span>mmap，是将文件/设备映射到内存中，进程可以通过读写内存的方式，实现对被mmap文件的操作。进程通过mmap映射相同的文件，实现共享内存方式的通信。对于大量频繁读写的文件，mmap相对read/write的方式，避免了内核空间-&gt;用户空间的数据传输和切换（epoll）。</span></p><p><span>具体实现：对应着有三个函数：</span></p><p><strong><span>epoll_create</span></strong><span>：epoll_create相当于在内核中创建一个存放fd的数据结构。在select和poll方法中，内核都没有为fd准备存放其的数据结构，只是简单粗暴地把数组或者链表复制进来；而epoll则不一样，epoll_create会在内核建立一颗专门用来存放fd结点的红黑树，储监控的文件描述符，后续如果有新增的fd结点，都会注册到这个epoll红黑树上。</span></p><p><strong><span>epoll_ctr</span></strong><span>：select和poll会一次性将监听的所有fd都复制到内核中，而epoll不一样，当需要添加一个新的fd时，会调用epoll_ctr，给这个fd注册一个回调函数，然后将该fd结点注册到内核中的红黑树中。当该fd对应的设备活跃时，会调用该fd上的回调函数，将该结点存放在一个就绪链表（存储就绪的文件描述符）中。这也解决了在内核空间和用户空间之间进行来回复制的问题。</span></p><p><strong><span>epoll_wait</span></strong><span>：epoll_wait的做法也很简单，其实直接就是从就绪链表中取结点，这也解决了轮询的问题，时间复杂度变成O(1)</span></p><p><span>Level和Edge指的就是触发点，Level为只要处于水平，那么就一直触发，而Edge则为上升沿和下降沿的时候触发。当缓冲区有数据可取的时候，ET会触发一次事件，之后就不会再触发，而LT只要我们没有取完缓冲区的数据，就会一直触发。</span></p></li></ul><h5 id='nio'><span>NIO</span></h5><p><a href='https://tech.meituan.com/2016/11/04/nio.html' target='_blank' class='url'>https://tech.meituan.com/2016/11/04/nio.html</a></p><p><a href='https://xie.infoq.cn/article/fb524c4992beea6bb4487af87' target='_blank' class='url'>https://xie.infoq.cn/article/fb524c4992beea6bb4487af87</a></p><p><a href='https://www.cnblogs.com/loveer/p/11479887.html' target='_blank' class='url'>https://www.cnblogs.com/loveer/p/11479887.html</a></p><p><span>1，是一种同步非阻塞的 I/O 模型，在等待就绪阶段都是非阻塞的，真正的 I/O 操作是同步阻塞。是 I/O 多路复用的基础，成为解决高并发与大量连接、I/O 处理问题的有效方式。</span></p><p><span>2，服务器端同步阻塞 I/O 处理:socket.accept()、socket.read()、socket.write() 三个主要函数都是同步阻塞的，当一个连接在处理 I/O 的时候，系统是阻塞的，所以使用多线程时，就可以让 CPU 去处理更多的事情。低并发下结合线程池使得创建和回收成本相对较低，并且编程模型简单。创建和销毁都是重量级的系统函数，线程本身占用较大内存，线程的切换成本是很高的，无法应对百万级连接。</span></p><p><span>3，所有的系统 I/O 都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。NIO 里用户最关心” 我可以读了”。NIO的读写函数可以立刻返回而不是柱塞，如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，将用于传输的通道全部注册到选择器上，选择器监控通道，当某一通道就绪后连接继续进行读写，没有必要开启多线程。没有线程切换，只是拼命的读、写、选择事件。</span></p><p><img src="D:/sync/Note/%25E9%259D%25A2%25E7%25BB%258F.assets/77752ed5.jpg" alt="77752ed5" style="zoom:50%;" /></p><p><span>4，Java NIO 实际读写时的核心在于：通道（Channel）和缓冲区（Buffer），选择器。通道表示打开到 IO 设备（文件流、套接字）的连接，对原 I/O 包中的流的模拟，负责传输；缓冲区用于容纳数据，负责存储，Channel的读写必须通过buffer对象，然后操作缓冲区，对数据进行处理。缓存区是双向的，既可以往缓冲区写入数据，也可以从缓冲区读取数据：缓冲区&lt;-&gt;然后缓冲区通过通道进行传输&lt;-&gt;从缓冲区取数据。选择器：把Channel通道注册到Selector中，通过Selecotr监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动，通过事件驱动实现单线程管理多个Channel的目的。</span></p><p><img src="D:/sync/Note/%25E9%259D%25A2%25E7%25BB%258F.assets/0ece5d16ec1345a5b4dc2149cb5a8b40_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="0ece5d16ec1345a5b4dc2149cb5a8b40_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0" style="zoom:50%;" /></p><p><span>缓冲区根据数据类型的不同，可以进行划分ByteBuffer、CharBuffer等。根据工作方式分：直接缓冲区(磁盘-&gt;内核地址空间中-&gt;用户地址空间中-&gt;读取到应用程序)与非直接缓冲区(将缓冲区建立在物理内存之中,读写数据直接通过物理内存进行)，</span></p><h5 id='上下文切换'><span>上下文切换</span></h5><ul><li><p><span>就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</span></p></li><li><p><span>进程上下文切换 ：进程是由内核来管理和调度的，进程的切换只能发生在内核态，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）</span></p></li><li><p><span>线程上下文切换：当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</span></p></li><li><p><span>中断上下文切换：了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</span></p><p><img src="D:/sync/Note/%25E9%259D%25A2%25E7%25BB%258F.assets/2002319-20210104192307356-868531778.png" alt="2002319-20210104192307356-868531778" style="zoom:67%;" /></p></li></ul><h5 id='进程内存布局'><span>进程内存布局</span></h5><ul><li><span>程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码。</span></li><li><span>初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据。</span></li><li><span>未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据。</span></li><li><span>栈(Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。调用一个方法或函数会将一个新的栈帧（stack frame）压入到栈中，这个栈帧会在函数返回时被清理掉。由于栈中数据严格的遵守FIFO的顺序，这个简单的设计意味着不必使用复杂的数据结构来追踪栈中的内容，只需要一个简单的指针指向栈的顶端即可。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。</span></li><li><span>堆 (Heap):堆用于存储那些生存期与函数调用无关的数据，存储动态内存分配,需要程序员手工分配,手工释放，需要精细的算法来应付我们程序中杂乱的分配模式，优化速度和内存使用效率。分配方式类似于链表，会产生内存碎片。</span></li></ul></div></div>
</body>
</html>