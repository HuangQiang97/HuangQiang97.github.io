[toc]

### 15、结构

> 结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。
>
> - 结构可带有方法、字段、索引、属性、运算符方法和事件。
> - 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。
> - 与类不同，结构不能继承其他的结构或类。
> - 结构不能作为其他结构或类的基础结构。
> - 结构可实现一个或多个接口。
> - 结构成员不能指定为 abstract、virtual 或 protected。
> - 当使用 **New** 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。
> - 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。
> - **类是引用类型，结构是值类型。**结构类型直接存储成员数据，让其他类的数据位于堆中，位于栈中的变量保存的是指向堆中数据对象的引用。
> - 结构不支持继承。
> - 结构不能声明默认的构造函数。
> - 结构体中声明的字段无法赋予初值，但类可以。
> - 结构体的构造函数中，必须为结构体所有字段赋值，类的构造函数无此限制。
> - 结构是值类型，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用。
> - 在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能。

```
struct str
{
public int val;
public void func(int param)
	{
   	 ops;
	}
};
str strVal=new str();
strVal.val;
strVal.func(param);

```

>结构和类的适用场合分析：
>
>-  1、当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些；
>-  2、对于轻量对象，假如要声明一个含有许多对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低；
>-  3、在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。
>-  4、大多数情况下，目标类型只是含有一些数据，或者以数据为主。
>-  5、类的对象是存储在堆空间中，结构存储在栈中。堆空间大，但访问速度较慢，栈空间小，访问速度相对更快。当描述一个轻量级对象的时候，结构可提高效率，成本更低。
>-  6、假如在传值的时候希望传递的是对象的引用地址而不是对象的拷贝，就应该使用类。

> 结构体中声明的变量无法赋予初值,但类可以。

### 16、枚举

> 枚举是一组命名整型常量,枚举是值类型。枚举包含自己的值，且不能继承或传递继承。
>
> 适用于某些取值范围有限的数据
>
> 枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。

```
access_cate enum <enum_name>
{ 
    enumeration list ;// 是一个用逗号分隔的标识符列表。
};

enum_name.val;//获得枚举对象，对象为特殊枚举成员类型
(int) enmu_name.val;//获得对象的整数值

enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; //默认数值,从0开始
enum Days {Mon=1, tue=2, Wed=3, thu=4, Fri=5, Sat=6, Sun=7}; //自定义数值

Enum GenderEnum
{
    MALE = 1,
    FEMALE = 0
}

GenderEnum gender = GenderEnum.MALE;

// Enum => int
int genderId = (int)gender; // 1

// int => Enum
GenderEnum gender1 = (GenderEnum)0; // Female，超出枚举数值范围返回数值本身

// Enum => string
string genderStr = gender.ToString(); // Male

// string => Enum
GenderEnum gender2 = (GenderEnum)Enum.Parse(typeof(GenderEnum), "FEMALE"); // GenderEnum.FEMALE，超出字符串范围报错
```

> 枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0.若只有部分成员赋值，未赋值成员按前一个的值加一，以此类推。

### 17、类

```
<access specifier> class  class_name
{
    // member variables
    <access specifier> <data type> variableN;
	// 构造函数
     <access specifier> class_name(parameter_list)
    {
        // method body
    }
    //析构函数
    ~class_name(){
        // method body
    }
    // member methods
    <access specifier> <return type> methodN(parameter_list)
    {
        // method body
    }
}
```

> 类的默认访问标识符是 **internal**，成员的默认访问标识符是 **private**。
>
> 类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。
>
> 成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。

>    		类的构造函数 是类的一个特殊的成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有任何返回类型。默认的构造函数没有任何参数。

>析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。
>
>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。

>**static** 关键字把类成员(变量,函数)定义为静态的。意味着无论有多少个类的对象被创建，只会有一个该静态成员,类中只有一个该成员的实例,所有对象对他的修改都作用在该静态成员上。
>
>静态变量用于定义常量，它们的值可以通过直接调用类而不需要创建类的实例来获取。如果不声明为static，即使和Main方法从属于同一个类，也必须经过实例调用变量,静态变量可在成员函数或类的定义外部进行初始化。也可以在类的定义内部初始化静态变量。
>
>一个**成员函数**声明为 **static**。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。

>Main函数可以视为类的一个成员函数,可以正常访问类的所有静态变量与静态函数.

> 方法的成员变量会自动初始化。
>
> 方法的局部变量不会自动初始化必须在代码中显式初始化，之后才能在语句中使用它们的值。

>倘若在类的声明中没有显式地提供实例构造函数，在这种情况下编译器会提供一个隐式的默认构造函数，它具有以下特点：
>
>①不带参数；
>
>②方法体为空。
>
>但是如果声明了任何构造函数，那么编译器就不会把该类定义为默认构造函数。

> **字段**
>
> 字段又称为：“成员变量”，一般在类的内部做数据交互使用。
>
> 字段命名规范：camel命名法（首单词字母小写）。
>
> 私有化,仅供个人使用，所以一般是private修饰。
>
> **属性**
>
> 在面向对象设计中主要使用属性描述对象的静态特征。
>
> 一般采用Pascal命名法（首字母大写），数据类型要和对应的字段要一致。
>
> 属性其实就是外界访问私有字段的入口，属性本身不保存任何数据，在对属性赋值和读取的时候其实就是操作的对应私有字段。
>
> ```
>      //字段
>      private string studentName;
> 
>      //属性
>      public string StudentName
>      {
>          get { return (studentName); }
> 
>          set { studentName = value; }
>      }
> ```
>
> 

### 18、继承

> **class** <派生类> : <基类> { }

>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。可以在成员初始化列表中进行显式父类的初始化。
>
>```
>public SubClass(double l, double w,double,h) : base(l, w)
>{
>ops;
>}
>```
>
>子类可以通过base显式调用父类静态方法，访问父类静态变量：
>
>```
>base.methodName();
>base.val;
>```

> **C# 不支持多重继承**

> 创建子类对象调用子类的构造函数时，会首先隐式调用父类的无参构造函数。

### 19、多态

>多态是同一个行为具有多个不同表现形式或形态的能力。
>
>**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。
>
>多态性可以是静态的或动态的。
>
>在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。
>
>在 C# 中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自 Object。
>
>多态就是同一个接口，使用不同的实例而执行不同操作

> **静态多态性**
>
> 在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：
>
> - 函数重载
>
>     可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同，即参数列表必须不相同，返回值类型可以不相同。**不能重载只有返回类型不同的函数声明。**
>
>     - 方法名必须相同
>     - 参数列表必须不相同
>     - 返回值类型可以不相同
>
> - 运算符重载

> **动态多态性**
>
> 动态多态性是通过 **抽象类** 和 **虚方法** 实现的。
>
> ---------------------
>
> 
>
> 使用关键字 **abstract** 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。**抽象类**包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。
>
> 有关抽象类的一些规则：
>
> - 不能创建一个抽象类的实例。
>
> - 不能在一个抽象类外部声明一个抽象方法。
>
> - 通过在类定义前面放置关键字 **sealed**，可以将类声明为**密封类**。当一个类被声明为 **sealed** 时，它不能被继承。抽象类不能被声明为 sealed。
>
> ```
>   abstract class base_class
>    {
>        abstract public int method_name();
>    }
>    class sub_class:  base_class
>    {
>    		 public override int method_name ()
>       	 {
>       	 		ops;
>       	 }
>    }
> ```
>
> -----------------------------------
>
> 
>
> 当有一个定义在类中的函数需要在继承类中实现时，可以使用**虚方法**。
>
> 对虚方法的调用是在运行时发生的,虚方法是使用关键字 **virtual** 声明的。
>
> - 相同的方法名
> - 相同的参数列表
> - 相同的返回值
>
> ```
> public class base_class
> {
> 	public virtual void func()
>     {
>         ops;
>     }
>  }
> class sub_class:  base_class
> {
>    	public override void func() ()
>     {
>      	ops;
>     }
>  }
> 
> 
> ```
>
> **BaseClass obj=new SubClass();**
>
> 对象是子类的，但是声明时是用父类声明的，所以你用正常的办法访问不到子类自己的成员，只能访问到从父类继承来的成员,注意是继承来的，实质仍是子类的方法，而非直接使用父类的。
>
> 在子类中用 override 重写父类中用 virtual 申明的虚方法时，实例化父类调用该方法，执行时调用的是子类中重写的方法；override是重写，即将基类的方法在派生类里直接抹去重新写，故而调用的方法就是子类方法；
>
> 如果子类中用 new 覆盖父类中用 virtual 申明的虚方法时，实例化父类调用该方法，执行时调用的是父类中的虚方法；new只是将基类的方法在派生类里隐藏起来，故而调用的仍旧是基类方法。
>
> ```
> Base obj=new Base();
> ong.func();//调用父类虚方法
> SubClass obg=new SubClass();
> obg.func();//调用子类重写的虚方法
> Base obg=new SubClass();
> obg.func();//调用子类的虚方法
> 
> ```
>
> 依赖倒置原则，DIP,Dependency Inverse Principle DIP：
>
> 1、高层模块不应该依赖于低层模块, 二者都应该依赖于抽象。
>
> 2、抽象不应该依赖于细节,细节应该依赖于抽象。
>
> 如果调用了一个类的一个方法，就是依赖这个类，如果直接调用这个类的方法，就是依赖细节，细节就是具体的类，但如果调用的是它父类或者接口的方法，就是依赖抽象，  DIP 就是不要直接使用具体的子类，而是用它的父类的引用去调用子类的方法，这样就是依赖于抽象，不依赖具体。
>
> DIP 的好处就是解除耦合，用了 DIP 之后，调用者就不知道被调用的代码是什么，因为调用者拿到的是父类的引用，它不知道具体指向哪个子类的实例，更不知道要调用的方法具体是什么，所以，被调用代码被偷偷换成另一个子类之后，调用者不需要做任何修改， 这就是解耦了。
>
> 常见重写虚方法：
>
> ```
>  public override string ToString()
>  {
>  		return $"A:{a},B:{b}"
>  }
> ```
>
> 

>virtual和abstract都是用来修饰父类的，通过覆盖父类的定义，让子类重新定义。
>
>- 1.virtual修饰的方法必须有实现（哪怕是仅仅添加一对大括号),而abstract修饰的方法一定不能实现。抽象方法是一种强制派生类覆盖的方法。
>- 2.virtual可以被子类重写，虚方法也可以被直接调用，而abstract必须被子类重写，抽象类无法实例化，所以抽象方法没有办法被调用。
>- 3.如果类成员被abstract修饰，则该类前必须添加abstract，因为只有抽象类才可以有抽象方法。但虚方法可以存在于正常类中。
>- 4.无法创建abstract类的实例，只能被继承无法实例化。

>重载和重写
>
>- 重载(overload)是提供了一种机制, 在同一个作用域(一般指一个类)相同函数名通过不同的返回值类型以及参数来表来区分的机制。
>
>- 重写(override)是用于子类中为满足自己的需要重写基类的虚方法,这样在派生类中提供一个新的方法。他们必须：相同的方法名，相同的参数列表，相同的返回值。

> **隐藏方法**
>
> 在派生类中定义的和基类中的某个方法同名的方法，使用 new 关键字定义。
>
> ```
> 父类：public void func(){ops;}
> 子类：public new void func(){ops;}或 new public  void func(){ops;}
> ```
>
> - 隐藏方法不但可以隐藏基类中的虚方法，而且也可以隐藏基类中的非虚方法。
>
> - 隐藏方法中父类的实例调用父类的方法，子类的实例调用子类的方法。
>
> - 重写方法中子类的变量调用子类重写的方法，父类的变量要看这个父类引用的是子类的实例还是本身的实例，如果引用的是父类的实例那么调用基类的方法，如果引用的是派生类的实例则调用派生类的方法。
>
> ```
> Base obj=new Base();
> ong.func();//调用父类方法
> SubClass obg=new SubClass();
> obg.func();//调用子类方法
> Base obg=new SubClass();
> obg.func();//调用父类的虚方法
> ```

### 20、运算符重载

> 重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。

```
public static result-type operator unary-operator ( op-type operand ) //重载一元运算符
public static result-type operator binary-operator (op-type1 ope1,op-type2 ope2)//重载一元运算符

class A
{
	public static return_type operator + (A a,A b)
      {
      		ops;
      }
}
```

| 运算符                                | 描述                                         |
| :------------------------------------ | :------------------------------------------- |
| +, -, !, ~, ++, --                    | 这些一元运算符只有一个操作数，且可以被重载。 |
| +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。 |
| ==, !=, <, >, <=, >=                  | 这些比较运算符可以被重载。                   |
| &&, \|\|                              | 这些条件逻辑运算符不能被直接重载。           |
| +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。                   |
| =, ., ?:, ->, new, is, sizeof, typeof | 这些运算符不能被重载。                       |

> 运算符只能采用值参数，不能采用 ref 或 out 参数。
>
> C# 要求成对重载比较运算符。如果重载了==，则也必须重载!=，否则产生编译错误。同时，比较运算符必须返回bool类型的值，这是与其他算术运算符的根本区别。
>
> C# 不允许重载=运算符，但如果重载例如+运算符，编译器会自动使用+运算符的重载来执行+=运算符的操作。
>
> 运算符重载的其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。

### 21 、接口

> 接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 **"是什么"** 部分，派生类定义了语法合同 **"怎么做"** 部分。
>
> 接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。
>
> 接口使得实现接口的类或结构在形式上保持一致。
>
> 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。

> 接口使用 **interface** 关键字声明，它与类的声明类似。接口声明默认是 public 的。
>
> 通常接口命令以 **I** 字母开头,实现者方法名必须与接口定义的方法名一致。
>
> - 接口方法不能用public、protected、internal、private 、abstract等修饰。因为接口里面的方法都需要由外面接口实现去实现方法体，那么其修饰符必然是 public。C# 接口中的成员默认是 public 的。
> - 接口内不能有字段变量，构造函数。
> - 接口内可以定义属性（有get和set的方法）
>
> 
>
> ```
> acess_specifier interface IMyInterface
> {
>     void return_type MethodToImplement(params);
> }
> //实现
> class InterfaceImplementer : IMyInterface
> {
> 	public void MethodToImplement()
>     {
>         ops;
>     }
> }
> ```
>
> 如果一个接口继承其他接口，那么该接口的实现类或结构就需要实现所有接口的成员。
>
> - C# 是单继承，接口是解决 C# 里面类可以同时继承多个基类的问题。
> - 接口成员不能有 new、static、abstract、override、virtual 修饰符。有一点要注意，当一个接口继承一个接口，这2个接口中有相同的方法时，可用 new 关键字隐藏父接口中的方法。
>
> ```
> interface IParentInterface
> {
>     void ParentInterfaceMethod();
> }
> 
> interface IMyInterface : IParentInterface
> {
>     void MethodToImplement();
> }
> class InterfaceImplementer : IMyInterface
> {
> 	 public void MethodToImplement()
>     {
>         ops;
>     }
> 
>     public void ParentInterfaceMethod()
>     {
>         ops;
>     }
> }
> ```

>**接口和抽象类的区别**
>
>- 接口用于规范，抽象类用于共性。抽象类是类，所以只能被单继承，但是接口却可以一次实现多个。
>- 接口中只能声明方法，属性，事件，索引器。而抽象类中可以有方法的实现，也可以定义非静态的类变量。
>- 抽象类可以提供某些方法的部分实现，接口不可以。抽象类的实例是它的子类给出的。接口的实例是实现接口的类给出的。
>- 在抽象类中加入一个方法，那么它的子类就同时有了这个方法。而在接口中加入新的方法，那么实现它的类就要重新编写
>- 接口成员被定义为公共的，但抽象类的成员也可以是私有的、受保护的、内部的或受保护的内部成员（其中受保护的内部成员只能在应用程序的代码或派生类中访问）。
>- 接口不能包含字段、构造函数、析构函数、静态成员或常量。

### 22 、命名空间

> **命名空间**的设计目的是提供一种让一组名称与其他名称分隔开的方式。
>
> 命名空间的定义是以关键字 **namespace** 开始，后跟命名空间的名称，
>
> ```
> namespace namespace_name
> {
> // 代码声明
> }
> ```
>
> 调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面
>
> ```
> namespace_name.item_name;
> ```

> **using** 关键字表明程序使用的是给定命名空间中的名称。
>
> 可以使用 **using** 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。

> 命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间
>
> ```
> namespace namespace_name1 
> {
> 	// 代码声明
>         namespace namespace_name2 
>         {
>           // 代码声明
>         }
> }
> ```
>
> 可以使用点（.）运算符访问嵌套的命名空间的成员
>
> ```
> base_namespace.sub_namespace.item_name;
> using base_namespace.sub_namespace;
> ```

> **using static 指令：指定无需指定类型名称即可访问其静态成员的类型**
>
> ```
> using static System.Math;
> var = PI; // 直接使用System.Math.PI
> ```
>
> **起别名**
>
> ```
> using Project = PC.MyCompany.Project;
> ```

### 23、预处理指令

>预处理器指令指导编译器在实际编译开始之前对信息进行预处理。
>
>所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。
>
>C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。
>
>在 C# 中，**预处理器指令用于在条件编译中起作用**。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。

| 预处理器指令 | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| #define      | 它用于定义一系列成为符号的字符。                             |
| #undef       | 它用于取消定义符号。                                         |
| #if          | 它用于测试符号是否为真。                                     |
| #else        | 它用于创建复合条件指令，与 #if 一起使用。                    |
| #elif        | 它用于创建复合条件指令。                                     |
| #endif       | 指定一个条件指令的结束。                                     |
| #line        | 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。 |
| #error       | 它允许从代码的指定位置生成一个错误。                         |
| #warning     | 它允许从代码的指定位置生成一级警告。                         |
| #region      | 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 |
| #endregion   | 它标识着 #region 块的结束。                                  |

>\#define 预处理器指令创建符号常量。
>
>\#define 允许您定义一个符号，这样，通过使用符号作为传递给 #if 指令的表达式，表达式将返回 true。
>
>```
>#define symbol
>```
>
>---
>
>可以使用 #if 指令来创建一个条件指令。条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码。如果为假则不编译该部分代码。
>
>```
>#if symbol [operator symbol]...
>```
>
>常见运算符有：
>
>- == (等于)
>- != (不等于)
>- && (与)
>- || (或)
>
>也可以用括号把符号和运算符进行分组。
>
>条件指令用于在调试版本或编译指定配置时编译代码。
>
>**一个以 #if 指令开始的条件指令，必须显示地以一个 #endif指令终止。**
>
>条件编译在程序调试和运行上有重要的作用。比如预处理器指令可以禁止编译器编译代码的某一部分，如果计划发布两个版本的代码，即基本版本和有更多功能的企业版本，就可以使用这些预处理器指令来控制。在编译软件的基本版本时，使用预处理器指令还可以禁止编译器编译于额外功能相关的代码。另外，在编写提供调试信息的代码时，也可以使用预处理器指令进行控制。总的来说和普通的控制语句（if等）功能类似，方便在于预处理器指令包含的未执行部分是不需要编译的。
>
>```
>#define DEBUG
>#define VC_V10
>using System;
>public class TestClass
>{
>  public static void Main()
>  {
>
>     #if (DEBUG && !VC_V10)
>        Console.WriteLine("DEBUG is defined");
>     #elif (!DEBUG && VC_V10)
>        Console.WriteLine("VC_V10 is defined");
>     #elif (DEBUG && VC_V10)
>        Console.WriteLine("DEBUG and VC_V10 are defined");
>     #else
>        Console.WriteLine("DEBUG and VC_V10 are not defined");
>     #endif
>     Console.ReadKey();
>  }
>}
>```
>
>---
>
>**#warning 和 #error：**
>
>当编译器遇到它们时，会分别产生警告或错误。如果编译器遇到 #warning 指令，会给用户显示 #warning 指令后面的文本，之后编译继续进行。如果编译器遇到 #error 指令，就会给用户显示后面的文本，作为一条编译错误消息，然后会立即退出编译。
>
>```
>#if DEBUG && RELEASE  
>#error ("msg")
>#endif  
>#warning ("msg")
>```
>
>---
>
>**#region 和 #endregion**:\#region 和 #endregion 指令用于把一段代码标记为有给定名称的一个块.
>
>---
>
>\#line 指令可以用于改变编译器在警告和错误信息中显示的文件名和行号信息
>
>---
>
>\#pragma 指令可以抑制或还原指定的编译警告。与命令行选项不同，#pragma 指令可以在类或方法级别执行，对抑制警告的内容和抑制的时间进行更精细的控制。
>
>```
>#pragma warning disable 169    // 取消编号 169 的警告（字段未使用的警告）
>public class MyClass
>{
>   int neverUsedField;       // 编译整个 MyClass 类时不会发出警告
>}
>#pragma warning restore 169   // 恢复编号 169 的警告
>```
>
>

### 24、正则

**字符转义**

> 正则表达式中的反斜杠字符（\）指示其后跟的字符是特殊字符，或应按原义解释该字符。

| 转义字符 | 描述                                                    | 模式      |
| :------- | :------------------------------------------------------ | :-------- |
| **\a**   | 与报警 (bell) 符 \u0007 匹配。                          | \a        |
| **\b**   | 在字符类中，与退格键 \u0008 匹配。                      | [\b]{3,}  |
| **\t**   | 与制表符 \u0009 匹配。                                  | (\w+)\t   |
| **\r**   | 与回车符 \u000D 匹配,就是光标回到目前所在行的开头       | \r\n(\w+) |
| **\v**   | 与垂直制表符 \u000B 匹配。                              | [\v]{2,}  |
| **\f**   | 与换页符 \u000C 匹配。                                  | [\f]{2,}  |
| **\n**   | 与换行符 \u000A 匹配,就是另起一新行，光标在新行的开头； | \r\n(\w+) |
| **\e**   | 与转义符 \u001B 匹配。                                  | \e        |

**字符类**

>字符类与一组字符中的任何一个字符匹配。

| 字符类                 | 描述                                                         | 模式   | 匹配                                       |
| :--------------------- | :----------------------------------------------------------- | :----- | :----------------------------------------- |
| **[character_group]**  | 匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。 | [mn]   | "mat" 中的 "m"，"moon" 中的 "m" 和 "n"     |
| **[^character_group]** | 非：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。 | [^aei] | "avail" 中的 "v" 和 "l"                    |
| **[ first - last ]**   | 字符范围：与从 first 到 last 的范围中的任何单个字符匹配。    | [b-d]  | [b-d]irds 可以匹配 Birds、 Cirds、 Dirds   |
| **.**                  | 通配符：与除 \n 之外的任何单个字符匹配。 若要匹配原意句点字符（. 或 \u002E），您必须在该字符前面加上转义符 (\.)。 | a.e    | "have" 中的 "ave"， "mate" 中的 "ate"      |
| **\p{ name }**         | 与 *name* 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。 | \p{Lu} | "City Lights" 中的 "C" 和 "L"              |
| **\P{ name }**         | 与不在 *name* 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。 | \P{Lu} | "City" 中的 "i"、 "t" 和 "y"               |
| **\w**                 | 与任何单词字符匹配。                                         | \w     | "Room#1" 中的 "R"、 "o"、 "m" 和 "1"       |
| **\W**                 | 与任何非单词字符匹配。                                       | \W     | "Room#1" 中的 "#"                          |
| **\s**                 | 与任何空白字符匹配。                                         | \w\s   | "ID A1.3" 中的 "D "                        |
| **\S**                 | 与任何非空白字符匹配。                                       | \s\S   | "int __ctr" 中的 " _"                      |
| **\d**                 | 与任何十进制数字匹配。                                       | \d     | "4 = IV" 中的 "4"                          |
| **\D**                 | 匹配不是十进制数的任意字符。                                 | \D     | "4 = IV" 中的 " "、 "="、 " "、 "I" 和 "V" |

**定位点**

>定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符。

| 断言   | 描述                                                         | 模式     | 匹配                                            |
| :----- | :----------------------------------------------------------- | :------- | :---------------------------------------------- |
| **^**  | 匹配必须从字符串或一行的开头开始。                           | ^\d{3}   | "567-777-" 中的 "567"                           |
| **$**  | 匹配必须出现在字符串的末尾或出现在行或字符串末尾的 **\n** 之前。 | -\d{4}$  | "8-12-2012" 中的 "-2012"                        |
| **\A** | 匹配必须出现在字符串的开头。                                 | \A\w{4}  | "Code-007-" 中的 "Code"                         |
| **\Z** | 匹配必须出现在字符串的末尾或出现在字符串末尾的 **\n** 之前。 | -\d{3}\Z | "Bond-901-007" 中的 "-007"                      |
| **\z** | 匹配必须出现在字符串的末尾。                                 | -\d{3}\z | "-901-333" 中的 "-333"                          |
| **\G** | 匹配必须出现在上一个匹配结束的地方。                         | \G\(\d\) | "(1)(3)(5)[7](9)" 中的 "(1)"、 "(3)" 和 "(5)"   |
| **\b** | 匹配一个单词边界，也就是指单词和空格间的位置。               | er\b     | 匹配"never"中的"er"，但不能匹配"verb"中的"er"。 |
| **\B** | 匹配非单词边界。                                             | er\B     | 匹配"verb"中的"er"，但不能匹配"never"中的"er"。 |

**分组构造**

> 分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。

| 分组构造                             | 描述                                                 | 模式                                                         | 匹配                                                         |
| :----------------------------------- | :--------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **( subexpression )**                | 捕获匹配的子表达式并将其分配到一个从零开始的序号中。 | (\w)\1                                                       | "deep" 中的 "ee"                                             |
| **(?< name >subexpression)**         | 将匹配的子表达式捕获到一个命名组中。                 | (?< double>\w)\k< double>                                    | "deep" 中的 "ee"                                             |
| **(?< name1 -name2 >subexpression)** | 定义平衡组定义。                                     | (((?'Open'\()[^\(\)]*)+((?'Close-Open'\))[^\(\)]*)+)*(?(Open)(?!))$ | "3+2^((1-3)*(3-1))" 中的 "((1-3)*(3-1))"                     |
| **(?: subexpression)**               | 定义非捕获组。                                       | Write(?:Line)?                                               | "Console.WriteLine()" 中的 "WriteLine"                       |
| **(?imnsx-imnsx:subexpression)**     | 应用或禁用 *subexpression* 中指定的选项。            | A\d{2}(?i:\w+)\b                                             | "A12xl A12XL a12xl" 中的 "A12xl" 和 "A12XL"                  |
| **(?= subexpression)**               | 零宽度正预测先行断言。                               | \w+(?=\.)                                                    | "He is. The dog ran. The sun is out." 中的 "is"、 "ran" 和 "out" |
| **(?! subexpression)**               | 零宽度负预测先行断言。                               | \b(?!un)\w+\b                                                | "unsure sure unity used" 中的 "sure" 和 "used"               |
| **(?<=subexpression)**               | 零宽度正回顾后发断言。                               | (?<=19)\d{2}\b                                               | "1851 1999 1950 1905 2003" 中的 "99"、"50"和 "05"            |
| **(?                                 | 零宽度负回顾后发断言。                               | (?<!wo)man\b                                                 | "Hi woman Hi man" 中的 "man"                                 |
| **(?> subexpression)**               | 非回溯（也称为"贪婪"）子表达式。                     | [13579](?>A+B+)                                              | "1ABB 3ABBC 5AB 5AC" 中的 "1ABB"、 "3ABB" 和 "5AB"           |



**限定符**

> 限定符指定在输入字符串中必须存在上一个元素（可以是字符、组或字符类）的多少个实例才能出现匹配项。 限定符包括下表中列出的语言元素。

| 限定符         | 描述                                                   | 模式       | 匹配                                                         |
| :------------- | :----------------------------------------------------- | :--------- | :----------------------------------------------------------- |
| *****          | 匹配上一个元素零次或多次。                             | \d*\.\d    | ".0"、 "19.9"、 "219.9"                                      |
| **+**          | 匹配上一个元素一次或多次。                             | "be+"      | "been" 中的 "bee"， "bent" 中的 "be"                         |
| **?**          | 匹配上一个元素零次或一次。                             | "rai?n"    | "ran"、 "rain"                                               |
| **{ n }**      | 匹配上一个元素恰好 n 次。                              | ",\d{3}"   | "1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210" |
| **{ n ,}**     | 匹配上一个元素至少 n 次。                              | "\d{2,}"   | "166"、 "29"、 "1930"                                        |
| **{ n , m }**  | 匹配上一个元素至少 n 次，但不多于 m 次。[n,m]闭区间    | "\d{3,5}"  | "166"， "17668"， "193024" 中的 "19302"                      |
| ***?**         | 匹配上一个元素零次或多次，但次数尽可能少。             | \d*?\.\d   | ".0"、 "19.9"、 "219.9"                                      |
| **+?**         | 匹配上一个元素一次或多次，但次数尽可能少。             | "be+?"     | "been" 中的 "be"， "bent" 中的 "be"                          |
| **??**         | 匹配上一个元素零次或一次，但次数尽可能少。             | "rai??n"   | "ran"、 "rain"                                               |
| **{ n }?**     | 匹配前导元素恰好 n 次。                                | ",\d{3}?"  | "1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210" |
| **{ n ,}?**    | 匹配上一个元素至少 n 次，但次数尽可能少。              | "\d{2,}?"  | "166"、 "29" 和 "1930"                                       |
| **{ n , m }?** | 匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。 | "\d{3,5}?" | "166"， "17668"， "193024" 中的 "193" 和 "024"               |

**反向引用构造**

> 反向引用允许在同一正则表达式中随后标识以前匹配的子表达式。

| 反向引用构造   | 描述                                | 模式                  | 匹配             |
| :------------- | :---------------------------------- | :-------------------- | :--------------- |
| **\ number**   | 反向引用。 匹配编号子表达式的值。   | (\w)\1                | "seek" 中的 "ee" |
| **\k< name >** | 命名反向引用。 匹配命名表达式的值。 | (?< char>\w)\k< char> | "seek" 中的 "ee" |

**备用构造**

> 备用构造用于修改正则表达式以启用 either/or 匹配。

| 备用构造                        | 描述                                                         | 模式                                 | 匹配                                                         |
| :------------------------------ | :----------------------------------------------------------- | :----------------------------------- | :----------------------------------------------------------- |
| **\|**                          | 匹配以竖线 (\|) 字符分隔的任何一个元素。                     | th(e\|is\|at)                        | "this is the day. " 中的 "the" 和 "this"                     |
| **(?( expression )yes \| no )** | 如果正则表达式模式由 expression 匹配指定，则匹配 *yes*；否则匹配可选的 *no* 部分。 expression 被解释为零宽度断言。 | (?(A)A\d{2}\b\|\b\d{3}\b)            | "A10 C103 910" 中的 "A10" 和 "910"                           |
| **(?( name )yes \| no )**       | 如果 name 或已命名或已编号的捕获组具有匹配，则匹配 *yes*；否则匹配可选的 *no*。 | (?< quoted>")?(?(quoted).+?"\|\S+\s) | "Dogs.jpg "Yiska playing.jpg"" 中的 Dogs.jpg 和 "Yiska playing.jpg" |

**替换**

> 替换是替换模式中使用的正则表达式。

| 字符                                                         | 描述                                 | 模式                                 | 替换模式          | 输入字符串 | 结果字符串   |
| :----------------------------------------------------------- | :----------------------------------- | :----------------------------------- | :---------------- | :--------- | :----------- |
| **$**number                                                  | 替换按组 *number* 匹配的子字符串。   | \b(\w+)(\s)(\w+)\b                   | $3$2$1            | "one two"  | "two one"    |
| **${**name**}**                                              | 替换按命名组 *name* 匹配的子字符串。 | \b(?< word1>\w+)(\s)(?< word2>\w+)\b | ${word2} ${word1} | "one two"  | "two one"    |
| **$$**                                                       | 替换字符"$"。                        | \b(\d+)\s?USD                        | $$$1              | "103 USD"  | "$103"       |
| **$&**                                                       | 替换整个匹配项的一个副本。           | (\$*(\d*(\.+\d+)?){1})               | **$&              | "$1.30"    | "**$1.30**"  |
| **$`**          | 替换匹配前的输入字符串的所有文本。   | B+                                   | $` | "AABBCC"                             | "AAAACC"                             |                   |            |              |
| **$'**                                                       | 替换匹配后的输入字符串的所有文本。   | B+                                   | $'                | "AABBCC"   | "AACCCC"     |
| **$+**                                                       | 替换最后捕获的组。                   | B+(C+)                               | $+                | "AABBCCDD" | AACCDD       |
| **$_**                                                       | 替换整个输入字符串。                 | B+                                   | $_                | "AABBCC"   | "AAAABBCCCC" |

**杂项构造**

| 构造               | 描述                                                   | 实例                                                   |
| :----------------- | :----------------------------------------------------- | :----------------------------------------------------- |
| **(?imnsx-imnsx)** | 在模式中间对诸如不区分大小写这样的选项进行设置或禁用。 | \bA(?i)b\w+\b 匹配 "ABA Able Act" 中的 "ABA" 和 "Able" |
| **(?#注释)**       | 内联注释。该注释在第一个右括号处终止。                 | \bA(?#匹配以A开头的单词)\w+\b                          |
| **#** [行尾]       | 该注释以非转义的 # 开头，并继续到行的结尾。            | (?x)\bA\w+\b#匹配以 A 开头的单词                       |

**Regex 类**

> Regex 类用于表示一个正则表达式。

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public bool IsMatch( string input )** 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项。 |
| 2    | **public bool IsMatch( string input, int startat )** 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的开始位置开始。 |
| 3    | **public static bool IsMatch( string input, string pattern )** 指示指定的正则表达式是否在指定的输入字符串中找到匹配项。 |
| 4    | **public MatchCollection Matches( string input )** 在指定的输入字符串中搜索正则表达式的所有匹配项。 |
| 5    | **public string Replace( string input, string replacement )** 在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串。 |
| 6    | **public string[] Split( string input )** 把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割。 |

### 