### 数据库

[toc]

##### ACID

原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。事务中的所有操作要么全部执行，要么都不执行。⑴ 原子性：全部成功/全部失败回滚⑵ 一致性一致性状态变换到另一个一致性状态(2000+3000=1000+4000)。⑶ 隔离性并发多事务间无干扰（T1/T2=>T1+T2，T2+T1）⑷ 持久性：事务提交改变永久。

##### 隔离特性

* 脏读：一个事务处理过程里读取了另一个未提交的事务中的数据、注意回滚。读取了另一个事务未提交的脏数据。不加锁。

  不可重复读：一个事务范围内多次查询却返回了不同的数据值。读取了前一事务提交的数据。重点是修改数据。

  幻读：读取了另一条已经提交的事务。幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且更新成功后，再次读取，就出现了。重点是增加数据。

* 串行化：可避免脏读、不可重复读、幻读的发生，读加共享锁，写加排它锁，避免并行访问。

  可重复读：可避免脏读、不可重复读的发生，MySQL默认级别，事务一开始就构建要用到的数据的视图。

  读已提交： 允许读取并发事务已经提交的数据，可避免脏读的发生。每次执行sql语句的时候都重新生成视图。

  读未提交：允许读取尚未提交的数据，最低级别，任何情况都无法保证，无视图，直接到数据库中读取。

* 快照读取规则：当前事务内的更新，可以读到；版本未提交，不能读到；版本已提交，但是却在快照创建后提交的，不能读到；版本已提交，且是在快照创建前提交的，可以读到；

##### 分布式CAP

一致、可达、分区容错。分区通信失败无法避免，P总是成立。C：节点A修改后其它节点B读出来的也是新值，对此A 必须在写操作时，锁定B的读操作和写操作，只有数据同步后，才能重新开放B读写。锁定期间，B 不能读写，没有可用性。A：节点都可访问，为保证B的可用性，那么势必不能锁定 B，所以一致性不成立。

##### 引擎

* MyISAM：不支持事务，不支持外键，访问速度快，B+Tree 作为索引结构，索引和数据文件是分离的，能加载更多索引；支持表级锁，并发度有限；可以没有主键；
* InnoDB：更新密集的表，适合处理多重并发的更新请求；事务，默认的事务隔离级别为可重复读（REPEATABLE-READ），通过MVCC（并发版本控制）来实现；支持在线热备，有很成熟的在线热备解决方案；外键约束；支持自动增加列AUTO_INCREMENT属性；B+树构建索引，主键索引的叶子节点就是数据文件；支持表、行级锁，可以支持更高的并发；必须有唯一索引（如主键）；DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。

##### 外键

使两张表形成关联，外键只能引用外表中的主键的值。触发限制: 删除、更新。

##### 事务

日志文件 (redo log 和 undo log)，锁技术以及 MVCC

* 为了提升性能不会把每次的修改都实时同步到磁盘，然后使用后台线程去做缓冲池和磁盘之间的同步。更新数据到内存中->写redo log，prepare态->写bin log->事务提交 redo log变为commit态->写入磁盘。两阶段提交保证两份日志保持一致，当在写binlog之前崩溃时重启恢复后发现没有commit，回滚。当在commit之前崩溃,重启虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。系统对binlog定期做整库备份，崩溃时读取binlog进行恢复。用于保障已提交事务的持久化特性。
* undo log 提供了回滚和多个行版本控制（MVCC），对记录做变更操作时不仅会产生 redo 记录，也会产生 undo 记录，存放数据被修改前的值,用于在发生错误时才可以回滚。mvcc当读取的某一行被其他事务锁定时，它可以根据事务id从 undo log 中获取该行记录以前的数据是什么，从而提供该行版本信息。 
* 读写锁：读锁是可以共享的，写锁会排斥其他所有获取锁的请求。
* 事务的原子性是通过 undo log 来实现的；事务的持久性性是通过 redo log 来实现的；事务的隔离性是通过 (读写锁 + MVCC) 来实现的；事务的一致性是通过原子性，持久性，隔离性来实现的。

##### 索引

B+树，多叉树访问非叶节点少，减少磁盘访问。一个索引对应一棵 B+ 树，主键索引的叶子节点存的是整行数据，非主键索引的叶子节点内容是主键的值（找到后到ID索引树搜索一次），主键索引树占用存储与主键大小有关，二级索引树占用大小与索引列和主键列大小有关，自增主键。避免回表：查询字段为id和索引字段；复合字段索引，将经常访问的多个字段构建索引。

##### 最左匹配原则

* 最左匹配原则：如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到，同时遇到范围查询(>、<、between、like)就会停止匹配。构建一颗 B+ 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B+ 树，叶子节点存储的是第一个关键字的索引 a，而叶子节点存储的是三个关键字的数据。这里可以看出 a 是有序的，而 b，c 都是无序的。但是当在 a 相同的时候，b 是有序的，a,b 相同的时候，c 又是有序的。所以查询a=0,b=1,c=2时，过滤完a=0的数据后b有序，过滤完b=1数据后c有序，可以利用到abc的索引。a=0,b>1,c=2经过a,b过滤后c无需，只能用到索引a,b。

  <img src="D:/sync/Note/%25E9%259D%25A2%25E7%25BB%258F.assets/1804577-20200521182659976-48843100.png" alt="1804577-20200521182659976-48843100" style="zoom:70%;" />

##### 联合索引 

* 减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销。

* 覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。

* 效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！

##### 索引优化

* 如果查询语句中的where、order by、group 涉及多个字段，一般需要创建多列索引。
* 一般情况下，把选择性区分度高的字段放在前面，过滤后剩下更少数据（age/gender）。
* 避免使用范围查询很多情况下，范围查询都可能导致无法使用索引。
* 尽量避免查询不需要的数据（回表）。

##### 级联查询

先确定所连接的表，再确定所要查询的字段，确定连接条件以及连接方式

* inner join返回两个表基于连接条件实际匹配的行，即两个表交集。outer join返回两个表的并集结果，即匹配条件不满足的两个表的记录也将返回，mysql没有outer join 相关语句，但可以对left join和right join的结果用union连接来实现。

  ```sql
  select * from A a inner join B b on a.ID = b.ID;
  select * from A a left join B b on a.ID = b.ID union select * from A a right join B b on a.ID = b.ID;
  ```

* left join表示左侧表所有记录都将返回，并且不满足匹配条件的右侧连接表记录将返回null。

  ```sql
  select * from A a left join B b on a.ID = b.ID;
  ```

* right join与left join恰恰相反，表示右侧表所有记录都将返回，并且不满足匹配条件的左侧连接表记录将返回null。

  ```sql
  select * from A a right join B b on a.ID = b.ID;
  ```

  <img src="D:/sync/Note/%25E9%259D%25A2%25E7%25BB%258F.assets/20841286-f8e223bfa2c187f9.webp" alt="20841286-f8e223bfa2c187f9" style="zoom:50%;" />

##### 查询缓慢

1，偶尔慢：

* 数据库会在内存中把对应字段的数据更新了，并把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去。如果更新很频繁，这个时候 redo log 很快就会被写满了，需要立即把数据同步到磁盘的，只能暂停其他操作，就会导致我们平时正常的SQL语句突然执行的很慢。

* 语句涉及到的表锁或者行锁，并且被别人占据，只能慢慢等待别人释放锁了。使用`show processlist`命令来查看当前的状态哦。

2，频繁慢

* 字段没有索引：刚好查询的字段上没有索引，只能走全表扫描了，导致这条查询语句很慢。建立字段索引字段；复合字段索引，将经常访问的多个字段构建索引。
* 字段有索引，但却没有用索引：在字段的左边做了运算或者使用函数（where x-1>1000，where f(x)>1000），在查询的时候就不会用上索引。
* 字段有索引，但却没有用索引：非主键索引保存主键，需要到主键索引树中查询（回表），需要两次查询，如果所有行都匹配查询结果，就相当于全表扫描，并且每行数据走了两次索引，引擎会判断认为走两次所用还不如直接全表扫描开销小。系统是通过索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高，满足查询条件的数据越少，意味着走索引查询越有优势。通过采样的方式，来预测索引的区分度，由于统计的失误，导致区分度估计偏小，导致系统没有走索引，而是走了全表扫描。强制走索引：`select * from t force index(x) where x < 100 ;`，重新进行抽样：`analyze table t;`

##### B树、B+树

* B树是一颗多路平衡查找树：阶数m，每个节点最多有m-1个关键字，非根节点至少有m/2个关键字。每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

* B+树：非根节点元素范围：m/2 <= k <= m-1；内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，上移，高度增加。删除操作导致数量<m/2时，如果兄弟节点的元素大于m/2，可以直接通过兄弟节移动，然后更新父节点的索引，如果兄弟节点的元素不大于m/2，则将当前节点和兄弟节点合并，并且删除父节点中的key，上移，高度减少。

* B+树优势：非叶子结点只保存指针，所有关键字都在叶子结点，非叶子结点存储的元素更多，使得查询的IO次数更少。所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。所有的叶子节点形成了一个有序链表，更加便于查找（区间查询： 查询5-10，把到5这个标记，再找到10，然后串起来就行了）。

  <img src="D:/sync/Note/%25E9%259D%25A2%25E7%25BB%258F.assets/1460000020416603.webp" alt="1460000020416603" style="zoom:67%;" />