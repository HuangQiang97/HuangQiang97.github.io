







<center><h1>C#</h1></center>



[toc]

[C#规范](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/introduction)

## 基础

### 1、 开始

```c#

using System;//包含 System 命名空间
namespace HelloWorldApplication //一个 namespace 里包含了一系列的类
{
   class HelloWorld //文件名可以不同于类的名称。
   {
       /* 程序的执行从 Main 方法开始，Main 方法是所有 C# 程序的 入口点，
       说明当类执行时 类将做什么动作。*/
      static void Main(string[] args) 
      {
          /*类似于print(),{编号}为占位符
            占位符从零开始计数,
			输出时占位符编号与第二个参数字符位置一一对应.
		  */
         Console.WriteLine("msg:{0}","Hello World");//
         Console.ReadKey();//等待输入。
      }
   }
}
```

### 2、基本语法

>标识符必须以字母、下划线或 @ 开头，后面可以跟一系列的字母、数字（ 0 - 9 ）、下划线（ _ ）、@。
>
>标识符不能是 C# 关键字。除非它们有一个 @ 前缀。

**保留关键字**

| abstract  | as        | base     | bool       | break                    | byte                   | case    |
| --------- | --------- | -------- | ---------- | ------------------------ | ---------------------- | ------- |
| catch     | char      | checked  | class      | const                    | continue               | decimal |
| default   | delegate  | do       | double     | else                     | enum                   | event   |
| explicit  | extern    | false    | finally    | fixed                    | float                  | for     |
| foreach   | goto      | if       | implicit   | in                       | in (generic  modifier) | int     |
| interface | internal  | is       | lock       | long                     | namespace              | new     |
| null      | object    | operator | out        | out  (generic  modifier) | override               | params  |
| private   | protected | public   | readonly   | ref                      | return                 | sbyte   |
| sealed    | short     | sizeof   | stackalloc | static                   | string                 | struct  |
| switch    | this      | throw    | true       | try                      | typeof                 | uint    |
| ulong     | unchecked | unsafe   | ushort     | using                    | virtual                | void    |
| volatile  | while     |          |            |                          |                        |         |

**上下文关键字**

| add               | alias  | ascending | descending | dynamic | from    | get            |
| ----------------- | ------ | --------- | ---------- | ------- | ------- | -------------- |
| global            | group  | into      | join       | let     | orderby | partial (type) |
| partial  (method) | remove | select    | set        |         |         |                |

```
Console.Write();      输出不换行
Console.WriteLine();  输出并换行
Console.ReadLine();   读取键盘输入的所有字符，返回字符串。按下回车键退出 
Console.Read();       读取键盘输入的第一个字符，返回其对应的ASCII值。按下回车键退出，但不读取回车符，回车						符会留给下一行输入。
Console.ReadKey();    等待用户按下任意键并执行退出。
```

### 3、数据类型

**值类型**

>值类型变量可以直接分配给一个值。当声明一个 值类型时，系统分配内存来存储值。
>
>值类型不能包含 null 值；
>
>每个值类型都具有一个初始化该类型的默认值的隐式默认构造函数。

| 类型    | 描述                                 | 范围                                                    | 默认值 |
| ------- | ------------------------------------ | ------------------------------------------------------- | ------ |
| bool    | 布尔值                               | True 或 False                                           | False  |
| byte    | 8 位无符号整数                       | 0 到 255                                                | 0      |
| char    | 16 位 Unicode 字符                   | U +0000 到 U +ffff                                      | '\0'   |
| short   | 16 位有符号整数类型                  | -32,768 到 32,767                                       | 0      |
| float   | 32 位单精度6.0浮点型                 | -3.4 x 1038 到 + 3.4 x 1038                             | 0.0F   |
| int     | 32 位有符号整数类型                  | -2,147,483,648 到 2,147,483,647                         | 0      |
| double  | 64 位双精度浮点型                    | (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308                   | 0.0D   |
| sbyte   | 8 位有符号整数类型                   | -128 到 127                                             | 0      |
| ushort  | 16 位无符号整数类型                  | 0 到 65,535                                             | 0      |
| uint    | 32 位无符号整数类型                  | 0 到 4,294,967,295                                      | 0      |
| long    | 64 位有符号整数类型                  | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L     |
| ulong   | 64 位无符号整数类型                  | 0 到 18,446,744,073,709,551,615                         | 0      |
| decimal | 128 位精确的十进制值，28-29 有效位数 | (-7.9 x 1028 到 7.9 x 1028)  / 100 到 28                | 0.0M   |

>得到一个类型或一个变量在特定平台上的准确尺寸,表达式 *sizeof(type)* 产生以字节为单位存储对象或类型的存储尺寸

**引用类型**

>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用,它们指的是一个内存位置。
>
>内置引用类型有：**object**、**dynamic** 和 **string**。

>对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。
>
>对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值.
>
>```
>Object obg = 1;
>
>```
>
>装箱与拆线
>
>```
>int val = 8;
>object obj = val;//先装箱
>int nval = （int）obj;//再拆箱
>```
>
>object 只是复制了 int a 的值出来然后对其操作。对obj的操作不会影响到 int 原来的值。

>动态(dynamic)类型可以存储任何类型的值在动态数据类型变量中，这些变量的类型检查是在运行时发生的。
>
>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。
>
>```
>dynamic val="str";
>val.GetType();//获得实际类型。
>```

>字符串（String）类型允许给变量分配任何字符串值,可以通过两种形式进行分配：引号和 @引号。
>
>字符串的前面可以加 @（称作"逐字字符串"）将转义字符（\）、空格、换行符当作普通字符对待，即不解释字符串。
>
>```
>string str = "a\ta";// "a    a"
>
>string str = @"a\ta";// "a\ta"
>```

>指针类型变量存储另一种类型的内存地址: **type* identifier;**

> 值类型，声明一个值类型的时候，是在“栈”中开辟一个内存空间x1来存放对应的值，当值类型的值发生改变的时候，则直接修改该内存空间x1所保存的值。
>
> 在复制到另一个变量时：在“栈”中开辟一个新的内存空间x2用来保存传递过来的值 ，二者独立变化。
>
> ---
>
> 引用类型，声明一个引用类型的时候，首先是在“堆”中开辟一个内存空间x1来存放对应的值，然后在“栈”中开辟一个内存空间p1用于保存在“堆”中开辟的内存空间x1的地址。当系统调用引用类型的时候，首先去“栈”p1中获取到地址，然后根据地址在“堆”中找到x1对应的内存空间来获取到对应值。
>
> 在赋值到另一个变量时：在栈中开辟一个空间p2，指向x1。两个变量同时变化。
>
> ---
>
>  string 是一个特殊的引用类型，当将 a 赋给 b 的时候，首先是在“堆”中开辟一个新的内存空间x2用于保存值 x1所存储的值，然后在“栈”中开辟一个内存空间p2用于保存x2地址，二者独立变化。
>
> 当修改 a 值时，并不是修改“堆”中 内存空间x1的值，而是在“堆”中重新开辟一个新的内存空间x3用于保存 a 修改后的值，然后将 a 在“栈”中对应的内存空间p1的所保存的地址修改成x3，而“堆”中的 x1 内存空间将在下次的垃圾回收中被回收利用。

>从内存上看，值类型是在栈中的操作，而引用类型是在堆中的操作。导致值类型存取速度快，引用类型存取速度慢。
>
>从本质上看，值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用。值类型在栈是具体的那个数值，而引用类型是存放那个数值的空间地址。
>
>从来源上看，值类型继承自System.ValueType，引用类型继承自System.Object。特别的：结构体是值类型，类和string是引用类型。
>
>当一个值类型转换为对象类型时，则被称为 **装箱**；另一方面，当一个对象类型转换为值类型时，则被称为 **拆箱**。
>
>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。

### 4、类型转换

>```
>val=(type)val;
>val=Convert.func(val);
>
>```
>
>隐式转换：C# 默认的以安全方式进行的转换。本质是从小存储容量数据类型自动转换为大存储容量数据类型，从派生类转换为基类。
>
>显式转换：通过用户使用预定义的函数显式完成的，显式转换需要强制转换运算符。转换类型的范围大小和从属关系和隐式转换相反。显式转换可能会导致数据出错，或者转换失败，甚至无法编译成功。
>
>
>
>---
>
>
>
>**int tmp=Convert.ToInt32(param);**
>
>参数可以为多种类型（str, bool，DateTime 等），继承自 Object 的并且可以转换为int 的对象都可以转换;
>
>参数为null会返回 0 而不会产生任何异常;
>
>采取的取舍是进行四舍五入;
>
>溢出会报错；
>
>
>
>**int tmp=int.Parse(str);**
>
>参数为null会产生异常,；
>
>参数只能是整型字符串类型;
>
>溢出会报错；
>
>
>
>**bool bo1=int.TryParse(string str,out int tmp) ;**
>
>转换失败不会出现异常;
>
>tmp是输出值，如果转换成功则输出相应的值，转换失败则输出0；
>
>bol表示转换是否成功,；
>
>参数str只能是整型字符串类型;
>
>溢出不会报错，tmp=0,bol=false；
>
>
>
>**int tmp=(int)param;**
>
>参数只能是数字类型；
>
>不能接受 NULL；
>
>截取浮点型的整数部分,
>
>溢出不报错，但是返回值为 -1。
>
>---
>
>如果是数字类型可以考虑直接用(int)强制转换，
>
>如果是整型字符串类型的，考虑用 int.Parse() 进行转换，
>
>如果不是这两种类型，再考虑用 Convert.ToInt32() 进行转换。
>
>---
>
>byte,short,double 的转换与int类似。

| 序号 | 方法 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |
| 2    | **ToByte** 把类型转换为字节类型。                            |
| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |
| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |
| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |
| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |
| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |
| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |
| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |
| 12   | **ToString** 把类型转换为字符串类型。                        |
| 13   | **ToType** 把类型转换为指定类型。                            |
| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |
| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |
| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |

>**Console.ReadLine()**：获得输入，以string形式返回。可通过Convert.func(val)进行类型转换。

### 5、常量

>整形常量
>
>​	前缀：0、0X,后缀：U、L、F
>
>浮点常量
>
>​	使用小数形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。3.14E-1
>
>在 C# 中没有全局变量的概念，所有变量必须由该类的实例进行操作，这样做提升了安全性，因此，我们在保存一些类的公共信息时，就会使用静态变量。

**转义**

| 转义序列   | 含义                       |
| ---------- | -------------------------- |
| \\\\       | \                      |
| \\'       | '                   |
| \\"        | "                      |
| \?         | ?                    |
| \a         | Alert             |
| \b         | 退格键（Backspace）        |
| \f         | 换页符（Form feed）        |
| \n         | 换行符（Newline）          |
| \r         | 回车                       |
| \t         | 水平制表符 tab             |
| \v         | 垂直制表符 tab             |

>**静态常量（编译时常量）const**
>
>常量使用 **const** 关键字来定义:const <data_type> <constant_name> = value;
>
>在编译时就确定了值，必须在声明时就进行初始化且之后不能进行更改，可在类和方法中定义。
>
>**动态常量（运行时常量）readonly**
>
>常量使用 **readonly** 关键字来定义:readonly <data_type> <constant_name> = value;
>
>在运行时确定值，只能在声明时或构造函数中初始化，只能在类中定义。
>
>在下面两种情况下：
>
>-  a、取值永久不变(比如圆周率、一天包含的小时数、地球的半径等)。
>-  b、对程序性能要求非常苛刻。
>
>可以使用 const 常量，除此之外的其他情况都应该优先采用 readonly 常量。
>
>---
>
>带有 private 私有访问修饰符的常量要以骆驼命名法命名，即以下划线开头，第一个单词的首字母小写，余下单词首字母大写。
>
>带有 public 公共修饰符、protected 受保护修饰符等的常量要以帕斯卡命名法命名，即各个单词首字母都要大写。

### 6、运算符

| 运算符 | 描述                     |
| ------ | --------------------   |
| &      | 按位与                  |
| \|     | 按位或                  |
| ^      | 按位异或，同为0，异为1    |
| ~      | 按位取反                |
| <<     | 二进制左移运算符。        |
| >>     | 二进制右移运算符。        |

| 运算符   | 描述                                   | 实例                                                         |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| sizeof() | 返回数据类型的大小。                   | sizeof(int)，将返回 4.                                       |
| typeof() | 返回 class 的类型。                    | typeof(StreamReader);                                        |
| &        | 返回变量的地址。                       | &a; 将得到变量的实际地址。                                   |
| *        | 返回指针指向的变量                     | *a; 将指向一个变量。                                         |
| X?A :B   | 条件表达式                             | 如果条件为真 ? 则为 A : 否则为 B                             |
| is       | 判断对象是否为某一类型。               | If( Ford is Car)                                             |
| as       | 强制转换，即使转换失败也不会抛出异常。 | Object obj = new StringReader("Hello");                                           StringReader r = obj as StringReader; |

>其中&，|的运算结果与&&，||完全相同，但&&和||的性能更好。因为&&和||都是检查第一个操作数的值，如果已经能判断结果，就根本不处理第二个操作数。

**运算优先级**

| 类别       | 运算符                                                       | 结合性   |
| ---------- | ------------------------------------------------------------ | -------- |
| 后缀       | ()、 []、 ->、  ++  、 - -                                   | 从左到右 |
| 一元       | +、 - 、  !、  ~、  ++ 、 - - 、  (type)  、  sizeof         | 从右到左 |
| 乘除       | *  、/ 、 %                                                  | 从左到右 |
| 加减       | +、  -                                                       | 从左到右 |
| 移位       | <<、 >>                                                      | 从左到右 |
| 关系       | <、 <= 、 >、 >=                                             | 从左到右 |
| 相等       | ==、  !=                                                     | 从左到右 |
| 位与 AND   | &                                                            | 从左到右 |
| 位异或 XOR | ^                                                            | 从左到右 |
| 位或 OR    | \|                                                           | 从左到右 |
| 逻辑与 AND | &&                                                           | 从左到右 |
| 逻辑或 OR  | \|\|                                                         | 从左到右 |
| 条件       | ? :                                                          | 从右到左 |
| 赋值       | =  、+= 、 -= 、 *= 、 /=  、%=、>>=、  <<= 、 &=、  ^=、   \|= | 从右到左 |
| 逗号       | ,                                                            | 从左到右 |

>移动后空出的位置补 0。
>
>左移相当于乘. 左移一位相当于乘2;
>
>右移相当于整除. 右移一位相当于除以 2;
>
>因为位移比乘除速度快，对效率要求高，而且满足 2 的幂次方的乘除运方，可以采用位移的方式进行。

### 7、判断

>**switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
>
>case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量。
>
>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 case 语句中有处理语句，则必须包含 **break** 或其他跳转语句。

### 8、循环

| 循环类型                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [while 循环](https://www.runoob.com/csharp/csharp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| [for/foreach 循环](https://www.runoob.com/csharp/csharp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |
| [do...while 循环](https://www.runoob.com/csharp/csharp-do-while-loop.html) | 当给定条件为真时，重复语句或语句组。它是在循环主体结尾测试条件， do...while 循环会确保至少执行一次循环。。 |
| [嵌套循环](https://www.runoob.com/csharp/csharp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |

>使用foreach可以迭代数组或者一个集合对象。
>
>foreach(type val in vals){ ops;}

>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。

| 控制语句 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| break    | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |
| continue | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |

>死循环
>
>当条件表达式不存在时，它被假设为真。

### 9、封装

| 修饰符             | 范围                       |
| ------------------ | ---------------------------------------- |
| public             | 任何公有成员可以被外部的类访问。       |
| protected          | 只有该类内部及其子类内部可以访问     |
| internal           | 同一个程序集的对象可以访问。 |
| protected internal | internal和protected的并集。 |
| private            | 只有同一个类中的函数可以访问它的私有成员。 |

>如果没有指定访问修饰符，则使用类成员的默认访问修饰符，即为 **private**。

| 修饰符             | 自身类内部|自身类对象|子类内部|子类对象|
| ------------------ | :----------------------------------------: | :----------------------------------------: | :----------------------------------------: | :----------------------------------------: |
| private      | ✔          |❌|❌|❌|
| protected internal |     ✔      |❌|✔|❌|
| internal           | ✔              |✔|✔|✔|
| protected | ✔               |✔|✔|✔|
| public      | ✔ |✔|✔|✔|

### 10、方法

>```
><Access Specifier> <Return Type> <Method Name>(Parameter List)
>{
>Method Body;
>}
>```

 **传参方式**

| 方式     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 值参数   | 这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。 |
| 引用参数 | 这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。引用参数是一个对变量的内存位置的引用，表示与提供给方法的实际参数具有相同的内存位置。**public** **void**  func(**ref** **int** x)  {    x += 1;   }   int x=1;func(**ref** x); |
| 输出参数 | 这种方式可以返回多个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。提供给输出参数的变量不需要赋值。                                                                                                                                                        **public** **void**  func(**out** **int** x)  {    x = 1;   }   int x;func(**out** x); |

>ref与out都是应用传递。
>
>使用ref型参数时，传入的参数必须先被初始化,在方法中对参数的任何更改都将反映在该变量中。
>
>对out而言，参数在传递之前不需要显式初始化，但必须在方法中对其完成初始化，即使在传入前已经声明，传入函数后即被设置为空。
>
>ref 和 out 关键字在运行时的处理方式不同，但在编译时的处理方式相同。因此，如果一个方法采用 ref 参数，而另一个方法采用 out 参数，则无法重载这两个方法。
>
>out应该是在方法内部做了分配地址的操作，然后把地址赋给外部的变量。但是ref是直接传递外部地址进方法。
>
>out适合用在需要retrun多个返回值的地方，而ref则用在需要被调用的方法修改调用者的引用的时候。
>
> 重载方法时若两个方法的区别仅限于一个参数类型为ref 另一个方法中为out，编译器会报错。

>扩展方法可以实现在不需要修改目标类，也不需要继承目标类的情况下为其添加一个方法。
>
>**规则：**
>
>-  1、扩展类必须为静态类，扩展方法必须为静态方法。
>-  2、扩展方法的第1个形参开头必须使用 “this” 关键字然后再填写扩展的目标类。
>-  3、如果需要接收参数则从第2个参数开始算起，第1个参数在真正调用方法时是隐藏的。
>
>```
>public static class ExtensionString
>{
>    //向 String 类扩展一个统计单词数量的方法
>    public static int CountWord(this String str)
>    {
>        return str.Split(' ').Length;
>    }
>}
>
>class MainClass
>{
>    public static void Main(string[] args)
>    {
>        Console.WriteLine("单词数量:" + "Hello World".CountWord()); //没有参数
>    }
>}
>```
>
>

### 11、可空类型

**nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。**

>？
>
>单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值。                                        int a :a默认为0；int? a:a默认值null
>
>```C#
>< data_type> ? <valiable_name> = null;
>int? val = null;
>bool? val = new bool?();
>```

>??
>
>Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。
>
>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。
>
>```
>val3 = var1 ?? val2; // if val1==null val3=val2 else val3=val1
>```

### 12、数组

>数组由连续的内存位置组成的,最低的地址对应第一个元素，最高的地址对应最后一个元素。
>
>数组是一个引用类型,声明一个数组不会在内存中创建数组,在初始化后才创建对象。
>
>```
>type [] vals=new type[size]{var,var,var};
>type [] vals={var,var,var};
>type [] vals=new type[]{var,var,var};
>```
>
>C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。

>**多维数组**
>
>类似于多为矩阵
>
>```c#
>// type[ ,  ] vals=new type[m,n]{ { val,val }, { val,val } };//声明
>vals[i,j];//访问
>vals.GetLength(k) ;//获得第k维度长度
>```
>
>type[ ,  ] vals=new type[m,n]{ { val,val }, { val,val } };//声明
>vals[i,j];//访问
>vals.GetLength(k) ;//获得第k维度长度
>
>

> **交错数组**
>
> 交错数组是一维数组，是数组的数组
>
> ```
> type [][] vals=new type[k][]{new type[m]{val,val},new type[n]{val,val}}
> vals.Length,vals[i].Length;//获得长度。
> vals[i]; vals[i][j];//实现访问
> ```

> 传递数组作为函数的参数,可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。

> **参数数组**
>
> 参数数组通常用于传递未知数量的参数给函数。
>
> ```
>  prite int func(params typet[] vals){ops;}
> ```

> Array 类是 C# 中所有数组的基类

**属性**

| 序号 | 属性 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **IsFixedSize** 获取一个值，该值指示数组是否带有固定大小。   |
| 2    | **IsReadOnly** 获取一个值，该值指示数组是否只读。            |
| 3    | **Length** 获取一个 32 位整数，该值表示所有维度的数组中的元素总数。 |
| 4    | **LongLength** 获取一个 64 位整数，该值表示所有维度的数组中的元素总数。 |
| 5    | **Rank** 获取数组的秩（维度）。                              |

**方法**

| 序号 | 方法 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **Array.Clear** 根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。 |
| 2    | **Array.Copy(Array, Array, Int32)** 从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。长度由一个 32 位整数指定。 |
| 3    | **obg.CopyTo(Array, Int32)** 从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。索引由一个 32 位整数指定。 |
| 4    | **obg.GetLength(axis)**  获取一个 32 位整数，该值表示指定维度的数组中的元素总数。 |
| 5    | **GetLongLength** 获取一个 64 位整数，该值表示指定维度的数组中的元素总数。 |
| 6    | **GetLowerBound** 获取数组中指定维度的下界。                 |
| 7    | **GetType** 获取当前实例的类型。从对象（Object）继承。       |
| 8    | **GetUpperBound** 获取数组中指定维度的上界。                 |
| 9    | **GetValue(Int32)** 获取一维数组中指定位置的值。索引由一个 32 位整数指定。 |
| 10   | **Array.IndexOf(Array, Object)** 搜索指定的对象，返回整个一维数组中第一次出现的索引。 |
| 11   | **Array.Reverse(Array)** 逆转整个一维数组中元素的顺序。      |
| 12   | **SetValue(Object, Int32)** 给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定。 |
| 13   | **Array.Sort(Array)** 使用数组的每个元素的 IComparable 实现来升序排序整个一维数组中的元素。 |
| 14   | **obg.ToString** 返回一个表示当前对象的字符串。从对象（Object）继承。 |

### 13、字符串

String 类有以下两个属性：

| 序号 | 属性名称 & 描述                                              |
| :--- | :----------------------------------------------------------- |
| 1    | **Chars** 在当前 *String* 对象中获取 *Char* 对象的指定位置。 |
| 2    | **Length** 在当前的 *String* 对象中获取字符数。              |

### 14、String 类的方法

String 类有许多方法用于 string 对象的操作。下面的表格提供了一些最常用的方法：

| 序号 | 方法名称 & 描述                                              |
| :--- | :----------------------------------------------------------- |
| 1   | **public static int Compare( string strA, string strB, bool ignoreCase )** 比较两个指定的 string 对象，小于0:strA小于strB;等于0:strA等于trB;大于0:strA大于strB，如果布尔参数为真时，该方法不区分大小写。 |
| 2   | **public static bool Equals( string a, string b )** 判断两个指定的 string 对象是否具有相同的值。 |
| 3   | **public static string Copy( string str )** 创建一个与指定字符串具有相同值的新的 String 对象。 |
| 4    | **public static string Format( string format, Object arg0 )** 把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。类似于**Console.Write();** |
| 5    | **public static string Join( string separator, string[] value)** 连接接一个字符串数组，使用指定的分隔符分隔每个元素。 |
| 6    | **public static string Concat( string str0, string str1 )** 连接两个 string 对象。 |
| 7   | **public bool Equals( string value )** 判断当前的 string 对象是否与指定的 string 对象具有相同的值。 |
| 8   | **public string ToLower()** 把字符串转换为小写并返回。 |
| 9   | **public string ToUpper()** 把字符串转换为大写并返回。|
| 10  |**public char[] ToCharArray(  )** 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组.  |
| 11  | **public int IndexOf( string value )** 返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。 |
| 12   | **public int IndexOf( char value )** 返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。 |
| 13   | **public int LastIndexOf( string value )** 返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。 |
| 14   |  **public bool Contains( string value )** 返回一个表示指定 string 对象是否出现在字符串中的值。 |
| 15   | **public string Insert( int startIndex, string value )** 返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。 |
| 16   | **public string Trim()** 移除当前 String 对象中的所有前导空白字符和后置空白字符。 |
| 17   | **public string Remove( int startIndex, int count )** 从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。 |
| 18   | **public string Replace( string oldValue, string newValue )** 把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。 |
| 19 | **public bool StartsWith( string value )** 判断字符串实例的开头是否匹配指定的字符串。 |
| 20 | **public bool EndsWith( string value )** 判断 string 对象的结尾是否匹配指定的字符串。 |

